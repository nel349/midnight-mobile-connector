# Mobile WASM Integration: Why It's Complex

## The Problem: Running Large WASM Modules on Mobile

As a mobile developer, you're used to importing JavaScript libraries with `import` or `require()`. But **WebAssembly (WASM) + JavaScript glue code** on mobile has unique challenges that web developers don't face.

### What We Were Trying to Do
- Load a **1.6MB WebAssembly module** (Midnight Network's cryptography)
- Execute **74KB of JavaScript "glue code"** (generated by wasm-bindgen)
- Run everything **locally on mobile** (no servers, for privacy)
- Make it work in **React Native WebView**

## Why This Was Incredibly Difficult

### 1. **React Native WebView Limitations**

**Normal web development**: You put JavaScript in separate files and load them
```javascript
<script src="my-large-script.js"></script>  // ✅ Works fine on web
```

**React Native WebView**: You must inject code as strings
```javascript
<WebView injectedJavaScript="console.log('hello');" />  // ❌ Has length limits!
```

**The Problem**: WebView's `injectedJavaScript` has hidden length/parsing limits. Our 74KB of JavaScript was getting **truncated** at ~500 characters, causing syntax errors.

### 2. **ES6 Modules Don't Work in WebView**

**What wasm-bindgen generates** (standard for web):
```javascript
export function myFunction() { ... }    // ✅ Works on web
export class MyClass { ... }           // ✅ Works on web  
```

**What WebView expects** (older CommonJS style):
```javascript
exports.myFunction = function() { ... }  // ✅ Works in WebView
exports.MyClass = class MyClass { ... }  // ✅ Works in WebView
```

**The Problem**: We had to **transform 74KB of generated JavaScript** from ES6 to CommonJS using regex replacements because there's no built-in module system in WebView.

### 3. **String Escaping Hell**

**The Nightmare**: When you put JavaScript code inside template literals inside JSON inside React Native, you get multiple layers of escaping:

```javascript
// This breaks everything:
const code = `
  const obj = { key: "value" };  // ❌ The { } breaks template parsing
  if (condition) { ... }         // ❌ More { } problems
`;

webView.postMessage(JSON.stringify({ code }));  // ❌ JSON escaping issues
```

**Why Mobile is Different**: Web developers load JS files directly. Mobile developers often need to embed JS as strings, creating escaping nightmares.

### 4. **WASM Instantiation Complexity**

**Web browsers**: Have built-in support for ES6 modules + WASM
```javascript
import init, { myFunction } from './my_module.js';  // ✅ Just works
await init();
```

**Mobile WebView**: You have to manually:
1. Load WASM binary as base64
2. Transform all JavaScript glue code  
3. Create proper module environment
4. Instantiate WASM with correct imports
5. Initialize wasm-bindgen bindings

## Our Solution Strategy

### 1. **Dynamic Code Loading via postMessage**
Instead of injecting 74KB in `injectedJavaScript`, we:
- Inject a tiny script (1KB) that listens for messages
- Send the large WASM loader code via `postMessage` 
- Execute dynamically with `eval()` in the WebView

```javascript
// React Native side - send large code via message
webView.postMessage(JSON.stringify({
  action: 'loadWasm',
  wasmLoaderCode: '/* 74KB of JavaScript */',
  wasmData: '/* 1.6MB base64 WASM */'
}));

// WebView side - receive and execute
window.addEventListener('message', (event) => {
  const { wasmLoaderCode } = JSON.parse(event.data);
  eval(wasmLoaderCode);  // Execute the large code
});
```

### 2. **ES6 to CommonJS Transformation**
We built a regex-based transformer for the generated JavaScript:

```javascript
// Transform all export patterns
code = code
  .replace(/export function (\w+)/g, 'exports.$1 = function')
  .replace(/export class (\w+)/g, 'exports.$1 = class $1') 
  .replace(/export const (\w+)/g, 'exports.$1')
  // ... handle all export patterns
```

### 3. **Manual WASM Environment Setup**
Created a proper execution environment for the glue code:

```javascript
// Create CommonJS-style environment
const exports = {};
const util = { TextEncoder, TextDecoder };
function require(name) { 
  if (name === 'util') return util; 
  return {}; 
}

// Execute transformed glue code
eval(transformedJavaScript);

// Instantiate WASM with proper imports  
const wasmModule = await WebAssembly.instantiate(wasmBytes, {
  './module.js': exports  // Connect JS glue to WASM
});
```

## Why This Matters for Mobile Developers

### **Privacy & Security**
- **Local execution**: No data leaves the device
- **No servers required**: Perfect for crypto/privacy apps
- **Full WASM performance**: Native-speed cryptography on mobile

### **Common Use Cases**
- **Cryptocurrency wallets**: Transaction signing, key generation
- **Image/video processing**: Running OpenCV, FFmpeg on mobile  
- **Machine learning**: Running TensorFlow Lite alternatives
- **Games**: High-performance game engines
- **Cryptography**: Zero-knowledge proofs, encryption

## Key Takeaways

1. **Mobile WASM ≠ Web WASM**: Different constraints, different solutions
2. **WebView has limits**: String injection, module systems, parsing rules
3. **Code generation tools** (like wasm-bindgen) **assume web environment**
4. **Mobile requires custom integration**: Transform, package, inject carefully

## The Result

We successfully loaded Midnight Network's **1.6MB WASM module** with **74KB JavaScript glue** in React Native, enabling:
- ✅ **166 WASM functions** available  
- ✅ **146 JavaScript functions** available
- ✅ **Full privacy-preserving cryptography** on mobile
- ✅ **No remote servers required**

This creates the foundation for mobile cryptocurrency wallets and privacy applications that run entirely on-device.